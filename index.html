<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Multilogin AI Helper</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://unpkg.com/@livechat/agent-app-sdk@1.6.3/dist/agentapp.umd.min.js"></script>
  <script src="https://alcdn.msauth.net/browser/2.38.1/js/msal-browser.min.js"></script>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif; 
      margin: 0; 
      background: #fff; 
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    .card { max-width: 760px; margin: 20px auto; padding: 20px; background: #fff; border: 1px solid #e1e5e9; border-radius: 12px; }
    h3 { margin: 0 0 16px 0; font-size: 16px; font-weight: 500; color: #1d2129; }
    .controls { display: flex; gap: 8px; margin-bottom: 16px; }
    button { 
      padding: 8px 12px; 
      border: 1px solid #ccd0d5; 
      border-radius: 6px;
      background: #f5f6f7; 
      color: #1c1e21; 
      cursor: pointer; 
      font-size: 14px;
      font-weight: 400;
      font-family: inherit;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    button:hover {
      background: #e4e6ea;
    }
    button:disabled {
      background: #f5f6f7;
      color: #bcc0c4;
      cursor: not-allowed;
    }
    #status { margin-top: 8px; font-size: 14px; color: #65676b; }
    .ok { color: #42b883; } 
    .err { color: #e41e3f; }
    .summary-grid { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 16px; }
    .section { display: flex; flex-direction: column; gap: 6px; }
    .field-header { display: flex; justify-content: space-between; align-items: center; }
    label { font-weight: 500; font-size: 14px; color: #1d2129; }
    .copy-btn {
      padding: 4px 8px;
      font-size: 12px;
      background: #f5f6f7;
      border: 1px solid #ccd0d5;
      border-radius: 4px;
      cursor: pointer;
      color: #65676b;
    }
    .copy-btn:hover {
      background: #e4e6ea;
    }
    .copy-btn.copied {
      background: #f0f0f0;
      color: #666;
      border-color: #ccc;
    }
    textarea { 
      width: 100%; 
      min-height: 120px; 
      resize: vertical; 
      padding: 8px; 
      border: 1px solid #ccd0d5; 
      border-radius: 6px;
      background: #fff; 
      font-size: 14px; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.4;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    textarea[readonly] { 
      background: #f5f6f7; 
      color: #1c1e21; 
    }
    .small { 
      font-size: 12px; 
      color: #65676b; 
      margin-top: 8px; 
    }

    
    /* Loading overlay styles */
    #loadingIndicator {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #e1e5e9;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(2px);
    }
    
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f4f6;
      border-radius: 50%;
      border-top-color: #1877f2;
      animation: spin 0.8s ease-in-out infinite;
      margin-bottom: 8px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      color: #1877f2;
      font-weight: 500;
      font-size: 14px;
      margin: 0;
    }
    
    .loading {
       pointer-events: none;
       opacity: 0.7;
       transform: scale(0.98);
       transition: all 0.2s ease;
     }
     
     /* Menu styles */
     .widget-header {
       display: flex;
       justify-content: space-between;
       align-items: center;
       margin-bottom: 16px;
     }
     
     .menu-container {
       position: relative;
       display: inline-block;
     }
     
     .menu-btn {
       background: none;
       border: none;
       font-size: 16px;
       cursor: pointer;
       padding: 4px;
       color: #65676b;
     }
     
     .menu-btn:hover {
       background: #f5f6f7;
     }
     
     .dropdown-menu {
       position: absolute;
       top: 100%;
       right: 0;
       background: white;
       border: 1px solid #ccd0d5;
       border-radius: 6px;
       min-width: 150px;
       z-index: 1000;
       display: none;
       box-shadow: 0 2px 8px rgba(0,0,0,0.1);
     }
     
     .dropdown-menu.show {
       display: block;
     }
     
     .dropdown-item {
       display: block;
       width: 100%;
       padding: 8px 12px;
       border: none;
       background: none;
       text-align: left;
       cursor: pointer;
       font-size: 14px;
       color: #1c1e21;
     }
     
     .dropdown-item:hover {
       background: #f5f6f7;
     }
     
     /* Language selector styles */
     .language-selector {
       margin-bottom: 16px;
       display: flex;
       align-items: center;
       gap: 8px;
     }
     
     .language-selector label {
       font-size: 14px;
       font-weight: 500;
       color: #1d2129;
       margin: 0;
     }
     
     .language-selector select {
       padding: 6px 8px;
       border: 1px solid #ccd0d5;
       border-radius: 6px;
       background: #fff;
       color: #1c1e21;
       font-size: 14px;
       font-family: inherit;
       cursor: pointer;
       min-width: 120px;
     }
     
     .language-selector select:focus {
       outline: none;
       border-color: #1877f2;
       box-shadow: 0 0 0 2px rgba(24, 119, 242, 0.2);
     }
     
     /* Telegram section styles */
     .telegram-section {
       margin-top: 24px;
       padding-top: 20px;
       border-top: 1px solid #e1e5e9;
     }
     
     .telegram-controls {
       display: flex;
       align-items: center;
       gap: 12px;
     }
     
     .telegram-result {
       flex: 1;
       padding: 8px 12px;
       background: #f5f6f7;
       border: 1px solid #ccd0d5;
       border-radius: 6px;
       font-size: 14px;
       color: #1c1e21;
       cursor: text;
       transition: background-color 0.2s ease;
       min-height: 20px;
       display: flex;
       align-items: center;
     }
     
     .telegram-result:hover {
       background: #e4e6ea;
     }
     
     .telegram-result.copied {
       background: #e8f5e8;
       border-color: #42b883;
       color: #42b883;
     }
     
     .telegram-result.inactive {
       background: #f8f9fa;
       color: #65676b;
       cursor: text;
       border-color: #dadde1;
     }
     
    .telegram-result.inactive:hover {
      background: #f8f9fa;
    }

    .ms-auth-section {
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid #e1e5e9;
    }

    .ms-auth-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .ms-auth-account {
      font-size: 13px;
      color: #1d2129;
      background: #f5f6f7;
      border: 1px solid #ccd0d5;
      border-radius: 6px;
      padding: 8px 12px;
      line-height: 1.4;
    }

    .ms-auth-account strong {
      display: block;
      font-weight: 600;
    }

    .ms-auth-account span {
      display: block;
      color: #65676b;
      font-size: 12px;
      margin-top: 2px;
    }

    .ms-auth-btn {
      align-self: flex-start;
    }

    .ms-auth-note {
      color: #65676b;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="widget-header">
      <h3>Multilogin AI Helper</h3>
      <div class="menu-container">
        <button class="menu-btn" onclick="toggleMenu()">‚ãØ</button>
        <div class="dropdown-menu" id="dropdownMenu">
          <button class="dropdown-item" onclick="updateSummary()">üîÑ Update</button>
          <button class="dropdown-item" onclick="copyAll()">üìã Copy all</button>
          <button class="dropdown-item" onclick="deleteSummary()">üóëÔ∏è Delete Summary</button>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="summBtn">üìù Summarize</button>
      <button id="addTagBtn">üè∑Ô∏è Get Tags</button>
    </div>

    <div class="language-selector">
      <label for="languageSelect">Summary language:</label>
      <select id="languageSelect">
        <option value="en">English</option>
        <option value="ru">–†—É—Å—Å–∫–∏–π</option>
        <option value="pt">Portugu√™s</option>
        <option value="zh">‰∏≠Êñá</option>
        <option value="vi">Ti·∫øng Vi·ªát</option>
      </select>
    </div>

    <div id="status">Widget loaded ‚úÖ</div>
    <div id="loadingIndicator" style="display:none; margin:16px 0;">
      <div class="spinner"></div>
      <p class="loading-text">Processing your request...</p>
    </div>

    <div class="summary-grid" aria-live="polite">
      <div class="section">
        <div class="field-header">
          <label for="issueSummary">Issue summary</label>
          <button class="copy-btn" onclick="copyToClipboard('issueSummary', this)" title="Copy">üìã</button>
        </div>
        <textarea id="issueSummary" readonly placeholder="Issue summary will appear here..."></textarea>
      </div>

      <div class="section">
        <div class="field-header">
          <label for="actionsTaken">Actions taken</label>
          <button class="copy-btn" onclick="copyToClipboard('actionsTaken', this)" title="Copy">üìã</button>
        </div>
        <textarea id="actionsTaken" readonly placeholder="Actions taken will appear here..."></textarea>
      </div>

    </div>

    <!-- Telegram section -->
    <div class="telegram-section">
      <div class="section">
        <div class="field-header">
          <label for="telegramResult">Telegram Username</label>
          <button class="copy-btn" onclick="copyTelegramResult()" title="Copy">üìã</button>
        </div>
        <div class="telegram-controls">
          <div class="telegram-result inactive" contenteditable="true" title="Edit Telegram username">
            <span id="telegramResult"></span>
          </div>
          <button id="updateTelegramBtn">üìù Update in PipeDrive</button>
        </div>
        <div class="small" style="margin-top: 8px; color: #65676b;">
          üí° The Telegram username is fetched automatically when you open a chat. If you want to change the 's Telegram username in Pipedrive ‚Äì enter the username and click the Update in PipeDrive button.
        </div>
      </div>
    </div>

    <div class="ms-auth-section">
      <div class="section">
        <div class="field-header">
          <label>Microsoft 365 Authorization</label>
        </div>
        <div class="ms-auth-details">
          <div id="msAuthAccount" class="ms-auth-account">Not authorized</div>
          <button id="msAuthBtn" class="ms-auth-btn">Sign in with Microsoft 365</button>
        </div>
        <div class="small ms-auth-note">
          Authorization is optional. When signed in, your Microsoft 365 agent profile will be automatically added to all webhooks.
        </div>
      </div>
    </div>

  </div>

  <script>
    (async () => {
      const statusEl = document.getElementById('status');
      const loadingEl = document.getElementById('loadingIndicator');
      const btnAdd = document.getElementById('addTagBtn');
      const btnSumm = document.getElementById('summBtn');
      const btnUpdateTelegram = document.getElementById('updateTelegramBtn');

      const issueEl = document.getElementById('issueSummary');
      const actionsEl = document.getElementById('actionsTaken');
      const telegramResult = document.getElementById('telegramResult');
      const languageSelect = document.getElementById('languageSelect');
      const msAuthBtn = document.getElementById('msAuthBtn');
      const msAuthAccount = document.getElementById('msAuthAccount');

      const MSAL_CONFIG = {
        auth: {
          clientId: 'b511a297-5a09-45c6-b0aa-c3288fc2588e',
          authority: 'https://login.microsoftonline.com/edc06450-2d29-4cac-be61-e22864c0bd58',
          redirectUri: window.location.origin
        },
        cache: {
          cacheLocation: 'localStorage',
          storeAuthStateInCookie: true
        }
      };

      const MSAL_SCOPES = ['User.Read', 'email', 'profile', 'offline_access'];
      const msalAvailable = typeof window.msal !== 'undefined';
      const msalInstance = msalAvailable ? new msal.PublicClientApplication(MSAL_CONFIG) : null;
      const msalLoginRequest = { scopes: MSAL_SCOPES };
      let msAccount = null;
      let msGraphProfile = null;

      function escapeHtml(value) {
        if (typeof value !== 'string') {
          return '';
        }

        return value
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function getMsUserInfo() {
        if (!msAccount) {
          return null;
        }

        return {
          account: {
            username: msAccount.username,
            name: msAccount.name,
            homeAccountId: msAccount.homeAccountId,
            environment: msAccount.environment,
            tenantId: msAccount.tenantId,
            localAccountId: msAccount.localAccountId
          },
          profile: msGraphProfile
        };
      }

      function appendMsUserInfo(payload) {
        const info = getMsUserInfo();
        if (info) {
          payload.ms365_user = info;
        }
        return payload;
      }

      function updateMsAuthUI() {
        const isAuthorized = Boolean(msAccount);

        if (btnAdd) {
          btnAdd.disabled = !isAuthorized;
          btnAdd.title = isAuthorized
            ? 'Request tags for the current chat'
            : 'Sign in with Microsoft 365 to enable tag updates';
        }

        if (!msAuthAccount) {
          return;
        }

        if (!msAccount) {
          msAuthAccount.innerHTML = 'Not authorized';
          if (msAuthBtn) {
            msAuthBtn.textContent = 'Sign in with Microsoft 365';
            msAuthBtn.disabled = !msalInstance;
          }
          return;
        }

        const displayName = escapeHtml(msGraphProfile?.displayName || msAccount.name || msAccount.username || '');
        const email = escapeHtml(
          msGraphProfile?.mail ||
          msGraphProfile?.userPrincipalName ||
          msAccount.username ||
          ''
        );

        const jobTitle = escapeHtml(msGraphProfile?.jobTitle || '');
        const department = escapeHtml(msGraphProfile?.department || '');
        const phone = escapeHtml((msGraphProfile?.mobilePhone || msGraphProfile?.businessPhones?.[0] || '') ?? '');

        const details = [
          displayName ? `<strong>${displayName}</strong>` : '',
          email ? `<span>${email}</span>` : '',
          jobTitle ? `<span>${jobTitle}${department ? ` ¬∑ ${department}` : ''}</span>` : '',
          phone ? `<span>${phone}</span>` : ''
        ].filter(Boolean).join('');

        msAuthAccount.innerHTML = details || 'Authorized';

        if (msAuthBtn) {
          msAuthBtn.textContent = 'Change Microsoft 365 account';
          msAuthBtn.disabled = false;
        }
      }

      async function acquireGraphToken(account) {
        if (!msalInstance || !account) {
          return null;
        }

        try {
          const tokenResponse = await msalInstance.acquireTokenSilent({
            ...msalLoginRequest,
            account
          });
          return tokenResponse.accessToken;
        } catch (error) {
          if (msal.InteractionRequiredAuthError && error instanceof msal.InteractionRequiredAuthError) {
            const tokenResponse = await msalInstance.acquireTokenPopup({
              ...msalLoginRequest,
              account
            });
            return tokenResponse.accessToken;
          }
          console.error('Failed to acquire Microsoft Graph token:', error);
          return null;
        }
      }

      async function fetchGraphJson(endpoint, accessToken) {
        if (!accessToken) {
          return null;
        }

        const response = await fetch(endpoint, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });

        if (!response.ok) {
          const errorText = await response.text().catch(() => '');
          throw new Error(`Graph request failed with status ${response.status}: ${errorText}`);
        }

        return response.json();
      }

      async function loadMsGraphProfile(account) {
        if (!account) {
          msGraphProfile = null;
          updateMsAuthUI();
          return;
        }

        try {
          const accessToken = await acquireGraphToken(account);
          if (!accessToken) {
            msGraphProfile = null;
            updateMsAuthUI();
            return;
          }

          const me = await fetchGraphJson('https://graph.microsoft.com/v1.0/me', accessToken);
          let memberOf = [];
          try {
            const groups = await fetchGraphJson('https://graph.microsoft.com/v1.0/me/memberOf?$select=displayName,id', accessToken);
            if (groups && Array.isArray(groups.value)) {
              memberOf = groups.value;
            }
          } catch (err) {
            console.warn('Failed to fetch Microsoft 365 group memberships:', err);
          }

          msGraphProfile = { ...me, memberOf };
          updateMsAuthUI();
        } catch (error) {
          console.error('Failed to load Microsoft 365 profile:', error);
          msGraphProfile = null;
          updateMsAuthUI();
        }
      }

      function setMsAccount(account) {
        msAccount = account || null;
        updateMsAuthUI();
      }

      async function initializeMsal() {
        if (!msalInstance) {
          if (msAuthBtn) {
            msAuthBtn.disabled = true;
            msAuthBtn.textContent = 'MSAL not loaded';
          }
          return;
        }

        try {
          await msalInstance.handleRedirectPromise();
        } catch (error) {
          console.error('MSAL redirect handling failed:', error);
        }

        const accounts = msalInstance.getAllAccounts();
        if (accounts.length > 0) {
          setMsAccount(accounts[0]);
          await loadMsGraphProfile(accounts[0]);
        } else {
          updateMsAuthUI();
        }
      }

      async function handleMsalLogin() {
        if (!msalInstance) {
          setStatus('‚ùå Microsoft 365 authorization unavailable', 'err');
          return;
        }

        try {
          const loginResult = await msalInstance.loginPopup({
            ...msalLoginRequest,
            prompt: 'select_account'
          });
          setMsAccount(loginResult.account);
          await loadMsGraphProfile(loginResult.account);
          setStatus('‚úÖ Microsoft 365 profile connected', 'ok');
        } catch (error) {
          console.error('Microsoft 365 login failed:', error);
          setStatus('‚ùå Failed to authorize in Microsoft 365', 'err');
        }
      }

      if (msAuthBtn) {
        msAuthBtn.addEventListener('click', handleMsalLogin);
      }

      updateMsAuthUI();
      await initializeMsal();

      const telegramField = (() => {
        const container = telegramResult.parentElement;

        function ensureSpan() {
          if (!container.contains(telegramResult)) {
            container.textContent = '';
            container.appendChild(telegramResult);
          }

          if (container.childNodes.length !== 1 || container.firstChild !== telegramResult) {
            container.replaceChildren(telegramResult);
          }
        }

        function normalize(value) {
          if (typeof value !== 'string') {
            return '';
          }
          return value.replace(/\s+/g, ' ').trim();
        }

        function applyActiveState(active) {
          if (active) {
            container.classList.remove('inactive');
          } else {
            container.classList.add('inactive');
          }
        }

        function set(value, { active = true } = {}) {
          ensureSpan();
          const sanitized = normalize(value ?? '');
          telegramResult.textContent = sanitized;
          container.classList.remove('copied');
          applyActiveState(active);
          return sanitized;
        }

        function get() {
          const raw = container.textContent ?? '';
          const sanitized = normalize(raw);
          set(sanitized, { active: true });
          return sanitized;
        }

        function clear({ keepActive = false } = {}) {
          return set('', { active: keepActive });
        }

        return { container, set, get, clear, normalize };
      })();
      
      // Load saved language preference
      const savedLanguage = localStorage.getItem('summaryLanguage') || 'en';
      languageSelect.value = savedLanguage;
      
      // Save language preference when changed
      languageSelect.addEventListener('change', function() {
        localStorage.setItem('summaryLanguage', this.value);
      });

      const SUMMARY_WEBHOOK = "https://npm.mlx.yt/webhook/livechat/summary";
      const TAGS_WEBHOOK = "https://npm.mlx.yt/webhook/livechat/add-tags";
      const TELEGRAM_WEBHOOK = "https://npm.mlx.yt/webhook/livechat/get-telegram";
      const UPDATE_TELEGRAM_WEBHOOK = "https://npm.mlx.yt/webhook/livechat/update-telegram";
      // –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π —Å–µ–∫—Ä–µ—Ç, –∏ –ø—Ä–æ–ø–∏—à–∏—Ç–µ —Ç–∞–∫–æ–π –∂–µ –≤ n8n –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
      const WEBHOOK_SECRET = "replace-with-real-secret";

      function setStatus(text, cls="") {
        statusEl.className = cls;
        statusEl.textContent = text;
      }

      let loadingInterval;
      
      function showLoading(message = "Processing") {
        // Hide the big loading indicator
        loadingEl.style.display = 'none';
        [btnAdd, btnSumm, btnUpdateTelegram].forEach(btn => btn.classList.add('loading'));
        
        // Start animated dots in status
        let dotCount = 0;
        loadingInterval = setInterval(() => {
          dotCount = (dotCount % 3) + 1;
          const dots = '.'.repeat(dotCount);
          setStatus(`‚è≥ ${message}${dots}`);
        }, 500);
      }
      
      function hideLoading() {
        loadingEl.style.display = 'none';
        [btnAdd, btnSumm, btnUpdateTelegram].forEach(btn => btn.classList.remove('loading'));
        
        // Stop animated dots
        if (loadingInterval) {
          clearInterval(loadingInterval);
          loadingInterval = null;
        }
      }
      
      // Copy to clipboard function
      window.copyToClipboard = async function(elementId, buttonEl) {
        try {
          const textarea = document.getElementById(elementId);
          const text = textarea.value;
          
          if (!text.trim()) {
            setStatus("‚ùå Nothing to copy", "err");
            return;
          }
          
          await navigator.clipboard.writeText(text);
          
          // Visual feedback
          const originalText = buttonEl.textContent;
          buttonEl.textContent = '‚úÖ Copied!';
          buttonEl.classList.add('copied');
          
          setTimeout(() => {
            buttonEl.textContent = originalText;
            buttonEl.classList.remove('copied');
          }, 2000);
          
          setStatus("‚úÖ Copied to clipboard", "ok");
        } catch (err) {
          console.error('Failed to copy: ', err);
          setStatus("‚ùå Failed to copy", "err");
        }
      };
       
       // Menu functions
       window.toggleMenu = function() {
         const menu = document.getElementById('dropdownMenu');
         menu.classList.toggle('show');
       };
       
       // Close menu when clicking outside
       document.addEventListener('click', function(event) {
         const menuContainer = document.querySelector('.menu-container');
         if (!menuContainer.contains(event.target)) {
           document.getElementById('dropdownMenu').classList.remove('show');
         }
       });
       
       window.updateSummary = function() {
         document.getElementById('dropdownMenu').classList.remove('show');
         // Trigger the same action as Summarize button
         btnSumm.click();
       };
       
       window.deleteSummary = function() {
         document.getElementById('dropdownMenu').classList.remove('show');
         if (confirm('Are you sure you want to delete the current summary?')) {
           issueEl.value = '';
           actionsEl.value = '';
           setStatus('‚úÖ Summary cleared', 'ok');
         }
       };
       
       window.copyAll = function() {
         document.getElementById('dropdownMenu').classList.remove('show');
         const issueText = issueEl.value.trim();
         const actionsText = actionsEl.value.trim();
         
         if (!issueText && !actionsText) {
           setStatus('‚ùå No content to copy', 'error');
           return;
         }
         
         let combinedText = '';
         if (issueText) {
           combinedText += 'Issue Summary:\n' + issueText;
         }
         if (actionsText) {
           if (combinedText) combinedText += '\n\n';
           combinedText += 'Actions Taken:\n' + actionsText;
         }
         
         navigator.clipboard.writeText(combinedText).then(() => {
           setStatus('‚úÖ All content copied to clipboard', 'ok');
         }).catch(() => {
           setStatus('‚ùå Failed to copy content', 'error');
         });
       };
       
       // Copy telegram result function
      window.copyTelegramResult = async function() {
        const telegramResultElement = telegramField.container;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–Ω–æ –ª–∏ –ø–æ–ª–µ
        if (telegramResultElement.classList.contains('inactive')) {
          setStatus('‚ùå No Telegram info to copy', 'err');
          return;
        }

        const text = telegramField.get();

        if (!text || text === "Click \"Get Telegram\" to fetch info from Pipedrive" || text === "Telegram not found in Pipedrive") {
          setStatus('‚ùå No Telegram info to copy', 'err');
          return;
        }
         
         try {
           await navigator.clipboard.writeText(text);
           
           // Visual feedback
           telegramResultElement.classList.add('copied');

           setTimeout(() => {
             telegramResultElement.classList.remove('copied');
           }, 2000);
           
           setStatus('‚úÖ Telegram copied to clipboard', 'ok');
         } catch (err) {
           console.error('Failed to copy: ', err);
           setStatus('‚ùå Failed to copy Telegram', 'err');
         }
       };
       
       function compactProfile(profile) {
        return {
          id: profile?.id,
          name: profile?.name,
          email: extractCustomerEmail(profile),
          geolocation: profile?.geolocation,
          customVariables: profile?.customVariables,
          preChatSurvey: profile?.chat?.preChatSurvey
        };
      }

      function isValidEmail(value) {
        if (typeof value !== 'string') {
          return false;
        }
        const trimmed = value.trim();
        if (!trimmed) {
          return false;
        }
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed);
      }

      function extractEmailFromPrechat(preChatSurvey) {
        if (!Array.isArray(preChatSurvey)) {
          return '';
        }

        for (const item of preChatSurvey) {
          const answer = item?.answer;
          if (isValidEmail(answer)) {
            return answer.trim();
          }
        }

        return '';
      }

      function findEmailInList(list) {
        if (!Array.isArray(list)) {
          return '';
        }

        for (const item of list) {
          if (isValidEmail(item?.email)) {
            return item.email.trim();
          }
        }

        return '';
      }

      function extractCustomerEmail(profile) {
        if (!profile || typeof profile !== 'object') {
          return '';
        }

        const chatCustomersEmail = findEmailInList(profile?.chat?.customers);
        const customersEmail = findEmailInList(profile?.customers);

        const emailCandidates = [
          profile.email,
          profile?.customer?.email,
          profile?.customer?.fields?.email,
          profile?.customer?.attributes?.email,
          profile?.fields?.email,
          profile?.attributes?.email,
          profile?.chat?.customer?.email,
          profile?.chat?.customer?.fields?.email,
          profile?.chat?.customer?.attributes?.email,
          chatCustomersEmail,
          customersEmail,
          profile?.customVariables?.email,
          extractEmailFromPrechat(profile?.chat?.preChatSurvey),
          extractEmailFromPrechat(profile?.preChatSurvey)
        ];

        for (const candidate of emailCandidates) {
          if (isValidEmail(candidate)) {
            return candidate.trim();
          }
        }

        return '';
      }

      // Detect browser timezone once
      const browserTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || null;

      const TELEGRAM_STATUS_MESSAGES = {
        found: { text: '‚úÖ Telegram username found', className: 'ok' },
        usernameNotFound: { text: '‚ùå Telegram username not found', className: 'err' },
        userNotFound: { text: '‚ùå The client was not found in PipeDrive', className: 'err' },
        invalid: { text: '‚ùå Invalid Telegram username', className: 'err' },
        fetchError: { text: '‚ùå Failed to fetch Telegram info', className: 'err' }
      };

      const TELEGRAM_MESSAGE_BLACKLIST = new Set([
        'telegram not found in pipedrive',
        'telegram found',
        'telegram updated successfully',
        'telegram info not found',
        'no telegram found',
        'no telegram username',
        'telegram username was deleted'
      ]);

      function isTruthy(value) {
        return value === true || value === 'true' || value === 1;
      }

      function isFalsy(value) {
        return value === false || value === 'false' || value === 0;
      }

      function sanitizeTelegramUsername(value) {
        if (typeof value !== 'string') {
          return '';
        }

        const trimmed = value.trim();
        if (!trimmed) {
          return '';
        }

        if (TELEGRAM_MESSAGE_BLACKLIST.has(trimmed.toLowerCase())) {
          return '';
        }

        return trimmed;
      }

      function pickTelegramUsername(source, keys) {
        if (!source || typeof source !== 'object') {
          return '';
        }

        for (const key of keys) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            const username = sanitizeTelegramUsername(source[key]);
            if (username) {
              return username;
            }
          }
        }

        return '';
      }

      function interpretTelegramLookupResponse(data) {
        const defaultResult = {
          username: '',
          status: TELEGRAM_STATUS_MESSAGES.usernameNotFound
        };

        if (!data) {
          return defaultResult;
        }

        if (Array.isArray(data)) {
          for (const item of data) {
            const username = pickTelegramUsername(item, ['telegram_is', 'telegram', 'tg_updated', 'telegram_username', 'telegram_id']);
            if (username) {
              return { username, status: TELEGRAM_STATUS_MESSAGES.found };
            }
          }
          return defaultResult;
        }

        if (typeof data !== 'object') {
          return defaultResult;
        }

        if (isTruthy(data.telegram_is_wrong) || isTruthy(data.invalid_telegram_username)) {
          return { username: '', status: TELEGRAM_STATUS_MESSAGES.invalid };
        }

        if (isTruthy(data.not_found_in_pipedrive)) {
          return { username: '', status: TELEGRAM_STATUS_MESSAGES.userNotFound };
        }

        if (isFalsy(data.user_found)) {
          return defaultResult;
        }

        if (isTruthy(data.user_found)) {
          if (Object.prototype.hasOwnProperty.call(data, 'new_telegram_username') && data.new_telegram_username === '') {
            return { username: '', status: TELEGRAM_STATUS_MESSAGES.usernameNotFound };
          }

          const username = pickTelegramUsername(data, ['tg_updated', 'telegram', 'telegram_username', 'telegram_id', 'telegram_is']);
          if (username) {
            return { username, status: TELEGRAM_STATUS_MESSAGES.found };
          }
        }

        const fallbackUsername = pickTelegramUsername(data, ['telegram', 'telegram_username', 'telegram_id', 'tg_updated', 'telegram_is']);
        if (fallbackUsername) {
          return { username: fallbackUsername, status: TELEGRAM_STATUS_MESSAGES.found };
        }

        return defaultResult;
      }

      function updateTelegramResultField(username) {
        return telegramField.set(username || '', { active: true });
      }

      function applyTelegramLookupResponse(data) {
        const { username, status } = interpretTelegramLookupResponse(data);
        updateTelegramResultField(username);
        if (status) {
          setStatus(status.text, status.className);
        }
        return { username, status };
      }

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å–∞–º–º–∞—Ä–∏ –∏ Telegram –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞
      function clearSummary() {
        const issueSummary = document.getElementById('issueSummary');
        const actionsTaken = document.getElementById('actionsTaken');
        
        if (issueSummary) {
          issueSummary.value = '';
          issueSummary.placeholder = 'Issue summary will appear here...';
        }
        
        if (actionsTaken) {
          actionsTaken.value = '';
          actionsTaken.placeholder = 'Actions taken will appear here...';
        }
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–ª–µ Telegram
        telegramField.clear();
        telegramField.container.classList.add('inactive');
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—ã–π
        setStatus('Ready');
        
        console.log('Summary and Telegram cleared for new dialog');
      }

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è Telegram
      async function autoGetTelegram(profile) {
        const chatId = profile?.chat?.chat_id || profile?.chat?.chatId || profile?.chat?.id || profile?.chat_id;
        const threadId = profile?.chat?.id || profile?.chat?.thread_id || profile?.chat?.threadId;
        const customerEmail = extractCustomerEmail(profile);

        if (!chatId || !threadId) {
          console.log('Missing required data for auto Telegram fetch:', { chatId, threadId, customerEmail });
          return;
        }

        const body = {
          chat_id: chatId,
          thread_id: threadId,
          profile: compactProfile(profile),
          client_time_zone: browserTimeZone,
          customer_email: customerEmail || null
        };

        appendMsUserInfo(body);

        try {
          const resp = await fetch(TELEGRAM_WEBHOOK, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Webhook-Secret": WEBHOOK_SECRET
            },
            body: JSON.stringify(body)
          });

          if (!resp.ok) {
            console.error('Failed to fetch Telegram info, status:', resp.status);
            updateTelegramResultField('');
            setStatus(TELEGRAM_STATUS_MESSAGES.fetchError.text, TELEGRAM_STATUS_MESSAGES.fetchError.className);
            return;
          }

          const data = await resp.json();
          applyTelegramLookupResponse(data);
        } catch (error) {
          console.error('Auto Telegram fetch request failed:', error);
          updateTelegramResultField('');
          setStatus(TELEGRAM_STATUS_MESSAGES.fetchError.text, TELEGRAM_STATUS_MESSAGES.fetchError.className);
        }
      }

      // Init LiveChat widget
      let widget;
      try {
        widget = await LiveChat.createDetailsWidget();
        setStatus("Widget initialized ‚úì", "ok");
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ Telegram –∏ —Å–±—Ä–æ—Å —Å–∞–º–º–∞—Ä–∏ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –¥–∏–∞–ª–æ–≥–∞
        widget.on('customer_profile', async (profile) => {
          console.log('Customer profile event received:', profile);
          
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–∞–º–º–∞—Ä–∏ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞
          clearSummary();
          
          try {
            await autoGetTelegram(profile);
          } catch (error) {
            console.error('Auto Telegram fetch failed:', error);
            // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—à–∏–±–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å —Ä–∞–±–æ—Ç–µ
          }
        });
        
      } catch (err) {
        setStatus("‚ùå Widget init failed", "err");
        console.error(err);
        return;
      }

      // Get Tags (–ø—Ä–∏–º–µ—Ä, –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å)
      btnAdd.addEventListener("click", async () => {
        try {
          if (!msAccount) {
            setStatus('‚ùå Sign in with Microsoft 365 to add tags', 'err');
            return;
          }

          const accessToken = await acquireGraphToken(msAccount);

          if (!accessToken) {
            setStatus('‚ùå Unable to acquire Microsoft 365 token', 'err');
            return;
          }

          showLoading("Updating tags ");

          const profile = await widget.getCustomerProfile();
          const chatId = profile?.chat?.chat_id || profile?.chat?.chatId || profile?.chat?.id || profile?.chat_id;
          const threadId = profile?.chat?.id || profile?.chat?.thread_id || profile?.chat?.threadId;

          if (!chatId || !threadId) {
            setStatus("‚ùå No chatId/threadId", "err");
            hideLoading();
            return;
          }

          const body = {
            chat_id: chatId,
            thread_id: threadId,
            tag: "AutoTaggingTest",
            profile: compactProfile(profile),
            client_time_zone: browserTimeZone
          };

          appendMsUserInfo(body);

          const resp = await fetch(TAGS_WEBHOOK, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Webhook-Secret": WEBHOOK_SECRET,
              "Authorization": `Bearer ${accessToken}`
            },
            body: JSON.stringify(body)
          });

          setStatus(resp.ok ? "‚úÖ Tags updated" : "‚ùå Error " + resp.status, resp.ok ? "ok" : "err");
        } catch (e) {
          setStatus("‚ùå Request failed", "err");
          console.error(e);
        } finally {
          hideLoading();
        }
      });

      // Summarize flow: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º webhook, —Å–µ—Ä–≤–µ—Ä –≤—ã—Ç—è–≥–∏–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–æ—Ç–æ–≤–æ–µ summary
      btnSumm.addEventListener("click", async () => {
        try {
          showLoading("Preparing summary request");
          const profile = await widget.getCustomerProfile();
          const chatId = profile?.chat?.chat_id || profile?.chat?.chatId || profile?.chat?.id || profile?.chat_id;
          const threadId = profile?.chat?.id || profile?.chat?.thread_id || profile?.chat?.threadId;

          if (!chatId || !threadId) {
            setStatus("‚ùå No chatId/threadId", "err");
            hideLoading();
            return;
          }

          // Update loading message
          if (loadingInterval) {
            clearInterval(loadingInterval);
            let dotCount = 0;
            loadingInterval = setInterval(() => {
              dotCount = (dotCount % 3) + 1;
              const dots = '.'.repeat(dotCount);
              setStatus(`‚è≥ Updating summary ${dots}`);
            }, 500);
          }

          // Map language codes to full English names
          const languageMap = {
            'en': 'English',
            'ru': 'Russian',
            'pt': 'Portuguese',
            'zh': 'Chinese',
            'vi': 'Vietnamese'
          };

          const body = {
            chat_id: chatId,
            thread_id: threadId,
            profile: compactProfile(profile),
            client_time_zone: browserTimeZone,
            summary_language: languageMap[languageSelect.value] || 'English'
          };

          appendMsUserInfo(body);

          const resp = await fetch(SUMMARY_WEBHOOK, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Webhook-Secret": WEBHOOK_SECRET
            },
            body: JSON.stringify(body)
          });

          if (!resp.ok) {
            const text = await resp.text();
            setStatus("‚ùå Summary request failed: " + resp.status, "err");
            return;
          }

          const data = await resp.json();
          // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∫–ª—é—á–µ–π
          issueEl.value = data.issue_summary || data.issueSummary || data.issue || "";
          actionsEl.value = data.actions_taken || data.actionsTaken || data.actions || "";

          setStatus("‚úÖ Summary loaded", "ok");
        } catch (e) {
          setStatus("‚ùå Summary failed", "err");
          console.error(e);
        } finally {
          hideLoading();
        }
      });

      // Update Telegram flow: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º webhook –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Telegram –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ PipeDrive
      btnUpdateTelegram.addEventListener("click", async () => {
        try {
          showLoading("Updating Telegram username");
          const profile = await widget.getCustomerProfile();
          const chatId = profile?.chat?.chat_id || profile?.chat?.chatId || profile?.chat?.id || profile?.chat_id;
          const threadId = profile?.chat?.id || profile?.chat?.thread_id || profile?.chat?.threadId;
          const customerEmail = extractCustomerEmail(profile);

          // –ü–æ–ª—É—á–∞–µ–º –≤–≤–µ–¥–µ–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º Telegram-–Ω–∏–∫
          const newTelegramUsername = telegramField.get();

          if (!chatId || !threadId) {
            setStatus("‚ùå No chatId/threadId", "err");
            hideLoading();
            return;
          }

          if (!customerEmail) {
            setStatus("‚ùå No customer email found", "err");
            hideLoading();
            return;
          }

          const body = {
            chat_id: chatId,
            thread_id: threadId,
            customer_email: customerEmail,
            telegram_username: newTelegramUsername,
            new_telegram_username: newTelegramUsername,
            profile: compactProfile(profile),
            client_time_zone: browserTimeZone
          };

          appendMsUserInfo(body);

          const resp = await fetch(UPDATE_TELEGRAM_WEBHOOK, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Webhook-Secret": WEBHOOK_SECRET
            },
            body: JSON.stringify(body)
          });

          if (!resp.ok) {
            const text = await resp.text();
            console.error('Telegram update failed:', resp.status, text);
            setStatus("‚ùå Telegram update failed: " + resp.status, "err");
            telegramField.set(newTelegramUsername, { active: true });
            return;
          }

          const data = await resp.json();
          const normalizedResponse = handleTelegramUpdateResponse(data, newTelegramUsername);
          telegramField.set(normalizedResponse.username, { active: true });
          if (normalizedResponse.status) {
            setStatus(normalizedResponse.status.text, normalizedResponse.status.className);
          }
        } catch (err) {
          console.error("Update Telegram error:", err);
          setStatus("‚ùå Update Telegram error", "err");
        } finally {
          hideLoading();
        }
      });
      
      function handleTelegramUpdateResponse(data, requestedUsername) {
        const normalizedRequested = telegramField.normalize(requestedUsername);
        const defaultResult = {
          username: normalizedRequested,
          status: { text: '‚úÖ Telegram username updated successfully', className: 'ok' }
        };

        if (!data || typeof data !== 'object') {
          return defaultResult;
        }

        if (data.not_found_in_pipedrive === true) {
          return {
            username: '',
            status: { text: '‚ùå The client was not found in PipeDrive', className: 'err' }
          };
        }

        if (Object.prototype.hasOwnProperty.call(data, 'updated_tg_username')) {
          const updated = telegramField.normalize(data.updated_tg_username);
          return {
            username: updated,
            status: {
              text: updated ? '‚úÖ Telegram username updated successfully' : '‚úÖ Telegram username removed successfully',
              className: 'ok'
            }
          };
        }

        if (data.user_found === false) {
          return {
            username: '',
            status: { text: '‚ùå The client was not found in PipeDrive', className: 'err' }
          };
        }

        if (data.success === false) {
          return {
            username: normalizedRequested,
            status: { text: '‚ùå Telegram update failed', className: 'err' }
          };
        }

        const interpreted = interpretTelegramLookupResponse(data);
        if (interpreted.username) {
          return {
            username: interpreted.username,
            status: { text: '‚úÖ Telegram username updated successfully', className: 'ok' }
          };
        }

        if (interpreted.status === TELEGRAM_STATUS_MESSAGES.userNotFound) {
          return {
            username: '',
            status: { text: '‚ùå The client was not found in PipeDrive', className: 'err' }
          };
        }

        if (interpreted.status === TELEGRAM_STATUS_MESSAGES.invalid) {
          return {
            username: normalizedRequested,
            status: { text: '‚ùå Invalid Telegram username', className: 'err' }
          };
        }

        return defaultResult;
      }

    })();
  </script>
</body>
</html>
